# 2. Delta Model and Snapshot Model

"Tommy, how did you find the information about the version control system I explained to you earlier?"

"It was very informative. It helped me a lot."

"I'm glad to hear that. Have you ever heard of the Delta Model and Snapshot Model?"

"I think I heard about 'delta' in math class, and 'snapshot'... hmm... Oh! I think I heard that Git creates snapshots like taking pictures when making commits."

"You've heard correctly. As you mentioned, Git uses the snapshot model."

"I'm planning to explain the delta model and snapshot model this time. Is that okay with you?"

"That sounds great! I've only heard about them before, so I'd love to take this opportunity to clearly understand what they are. I'm looking forward to it!"

### 2.1 Delta Model

In traditional version control systems, content is managed at the file level. When changes occur in a file, a new version is created by comparing it to the previous version and storing only the parts that have changed. This method is called the Delta Model.

The diagram \[Figure 2-1] illustrates how the Delta Model operates. Initially, files A, B, and C are checked in to create Version 1, and subsequently, versions are created up to Version 4. For each version, changes are recorded by comparing it with the previous version. When performing a checkout, all differences from the first version up to the version being checked out are combined to reconstruct the state at a specific point in time. Let's look at a concrete example to see how the Delta Model works.

Currently, there are two files on the hard disk, **favorite food.txt** and **hello.c**, which are ready to begin version control as shown in \[Figure 2-2]. The current contents of each file are used to create the initial version, Version 1, as depicted in \[Figure 2-3].

Since Version 1 is the initial version created to start version control, the contents of the file are identical to those of the original files.

Subsequently, as shown in Figure 2-4, the content “만두” (dumplings) is added to the favorite food.txt file, and the state at this point is saved to create Version 2. In this case, Version 2 contains only the single character “만두,” which is the difference compared to the previous version.

This time, the text “콩국수” (cold soybean noodle soup) is removed from the favorite food.txt file. Since the only difference between the current version and the previous version is the removal of the word “콩국수,” Version 3 will contain only the information about deleting that single word, as shown in Figure 2-5.

Finally, the content of the **hello.c** file is changed from “Hello, world\n” to “Hello, Git\n.” Since the only difference between the current version and the previous version is that the word "world" has been replaced with "Git," Version 4 will contain only this change, as shown in \[Figure 2-6].

In the Delta Model, new versions are generated by comparing the previous version with the current state and including only the modified content. So, how does it work when checking out a specific saved version? In the Delta Model, to reproduce the state of a specific version, each change from the first version up to the desired version is applied to reflect that state accurately.

When checking out Version 4, as illustrated in \[Figure 2-7], the changes from Version 1, Version 2, Version 3, and finally Version 4 are sequentially applied to compute and recreate the state of Version 4.

The Delta Model is efficient in terms of storage because it records only the changed content rather than the entire file. However, it has a significant performance drawback: when checking out a specific version, it must repeatedly apply the differences from the first version up to the desired version.

For instance, if there are 1,000 versions and you want to check out Version 999, you would need to apply all changes from Version 1 through Version 999 individually to reproduce the state of Version 999. As the number of versions increases—potentially reaching 10,000—the checkout performance inevitably deteriorates.

To address this limitation of the Delta Model, Git utilizes a Snapshot Model. This model allows for more efficient version retrieval by storing complete snapshots of files at specific points in time, thereby eliminating the need to apply multiple deltas sequentially during checkout.
